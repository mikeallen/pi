/*
 *
 * Ether Dream test - modified
 *
 * git clone https://github.com/j4cbo/j4cDAC
 * make
 */

#define _GNU_SOURCE

#include <math.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#include "etherdream.h"

#define CIRCLE_POINTS	10

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

struct etherdream_point circle[CIRCLE_POINTS];
struct etherdream_point xshape[4];

uint16_t colorsin(float pos) {
	int res = (sin(pos) + 1) * 32768;
	if (res < 0) return 0;
	if (res > 65535) return 65535;
	return res;
}

void fill_circle(float phase, int mode) {
	int i;
	for (i = 0; i < CIRCLE_POINTS; i++) {
		struct etherdream_point *pt = &circle[i];
		float ip = (float)i * 2.0 * M_PI / (float)CIRCLE_POINTS;
		float ipf = fmod(ip + phase, 2.0 * M_PI);;

		switch (mode) {
		default:
		case 0: {
			float cmult = .05 * sin(30 * (ip - phase/3));
			pt->x = sin(ip) * 100 * (1 + cmult);
			pt->y = cos(ip) * 100 * (1 + cmult);
			break;
		}
		case 1: {
			float cmult = .10 * sin(10 * (ip - phase/3));
			pt->x = sin(ip) * 20000 * (1 + cmult);
			pt->y = cos(ip) * 20000 * (1 + cmult);
			break;
			/* XXX broken */
/*
			float R = 3;
			float r = 5;
			pt->x = 2000 * ((R-r)*cos(ip+phase) + r*cos((R-r)*ip/r));
			pt->y = 2000 * ((R-r)*sin(ip+phase) - r*sin((R-r)*ip/r));
			break;
*/
		}
		case 2: {
			ip *= 3;
			float R = 5;
			float r = 3;
			float D = 5;

			pt->x = 2500 * ((R-r)*cos(ip + phase) + D*cos((R-r)*ip/r));
			pt->y = 2500 * ((R-r)*sin(ip + phase) - D*sin((R-r)*ip/r));
			break;
		}
		case 3: {
			int n = 5;
			float R = 5 * cos(M_PI/n) / cos(fmod(ip, (2*M_PI/n)) - (M_PI/n));
			pt->x = 3500 * R*cos(ip+phase);
			pt->y = 3500 * R*sin(ip+phase);
			break;
		}
		case 4: {
			float Xo = sin(ip);
			pt->x = 20000 * Xo * cos(phase/4);
			pt->y = 20000 * Xo * -sin(phase/4);
			ipf = fmod(((Xo + 1) / 2.0) + phase / 3, 1.0) * 2 * M_PI;
		}
		}

		pt->r = colorsin(ipf);
		pt->g = colorsin(ipf + (2.0 * M_PI / 3.0));
		pt->b = colorsin(ipf + (4.0 * M_PI / 3.0));
/*
		if (ipf < 2.0 * M_PI / 3.0) {
			pt->r = 65535;
			pt->g = pt->b = 0;
		} else if (ipf < 4.0 * M_PI / 3.0) {
			pt->g = 65535;
			pt->r = pt->b = 0;
		} else {
			pt->b = 65535;
			pt->r = pt->g = 0;
		}
*/
	}
}

void fill_xshape() {
    // Want colored lines between pts 0->1, and 2->3
    xshape[0].x = -100; xshape[0].y = -100;
    xshape[0].r = 0xFFFF; xshape[0].g = 0xFFFF; xshape[0].b = 0xFFFF; 
    xshape[1].x = 100; xshape[1].y = 100;
    xshape[1].r = 0xFFFF; xshape[1].g = 0xFFFF; xshape[1].b = 0xFFFF; 
    
    xshape[2].x = -100; xshape[2].y = 100;
    xshape[2].r = 0xFFFF; xshape[2].g = 0xFFFF; xshape[2].b = 0xFFFF; 
    xshape[3].x = 100; xshape[3].y = -100;
    xshape[3].r = 0xFFFF; xshape[3].g = 0xFFFF; xshape[3].b = 0xFFFF; 
}

void printEtherDreamPoint(struct etherdream_point p) {
    printf ("EtherDreamPoint (%d,%d) [%x,%x,%x] {%d,%d,%d}\n",p.x, p.y, p.r, p.g, p.b, p.i, p.u1, p.u2);
}

void printPointList(struct etherdream_point p[], int len) {
    int j;
    for (j=0; j<len; j++) {
        printf("POINT %d: ",j);
        printEtherDreamPoint(p[j]);
    }
    printf("\n");
    // NOTE: for the points generated by fill_circle
    // X&Y range from -104 to 104 
}

int main(int argc, char **argv) {

        /*
        int k;
        for (k = 0; k<1; k++){ 
            fill_circle((float)k/50, 0);
            printPointList(circle,CIRCLE_POINTS);
            fill_xshape();
            printPointList(xshape,4);
        }
        */

	etherdream_lib_start();

	/* Sleep for a bit over a second, to ensure that we see broadcasts
	 * from all available DACs. */
	usleep(1200000);

	int cc = etherdream_dac_count();
	if (!cc) {
		printf("No DACs found.\n");
		return 0;
	}

	int mode;
	if (argc > 1)
		mode = atoi(argv[1]);
	else
		mode = 0;

	int i;
	for (i = 0; i < cc; i++) {
		printf("%d: Ether Dream %06lx\n", i,
			etherdream_get_id(etherdream_get(i)));
	}

	struct etherdream *d = etherdream_get(0);

	printf("Connecting...\n");
	if (etherdream_connect(d) < 0)
		return 1;

	i = 0;
        if (argc == 3) {
            // ie ./test 0 1 - meansdraw an X
            while (1) {
                fill_xshape();
		int res = etherdream_write(d, xshape, 4, 30000, 1);
		if (res != 0) {
			printf("write %d\n", res);
		}
		etherdream_wait_for_ready(d);
		i++;
            }
        }
        else while (1) {
		fill_circle((float)i / 50, mode);

/* etherdream_write(d, pts, npts, pps, repeatcount)
 *
 * Write a "frame" consisting of pts (length npts) to d.
 *
 * If repeatcount is -1, pts will be sent to the laser repeatedly until new
 * data is received or until etherdream_stop is called. Otherwise, the points
 * will be sent repeatedly at most npts times, and then the stream will
 * automatically stop. pps specifies the output rate (30000 is a common value).
 * repeatcount must not be 0.
 *
 * The Ether Dream uses a continuous streaming protocol, so if new frames are
 * continuously sent, frame boundaries are not visible; however, to reduce
 * overhead, frames should be reasonably large (at least 50-100 points).
 */
		int res = etherdream_write(d, circle, CIRCLE_POINTS, 30000, 1);
		if (res != 0) {
			printf("write %d\n", res);
		}
		etherdream_wait_for_ready(d);
		i++;
	}

	printf("done\n");
	return 0;
}
